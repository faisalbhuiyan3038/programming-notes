# Understanding Next's Caching System

### Simulating a deployment locally
- First run `npm run build`.
- Then, start the project in production mode with `npm run start`.
- Now you can do see if everything is working correctly in the production build.

**Problem:**
In production mode, if you move from dev and deploy the project without doing any optimizations, you are going to run into issues with db, where the snippet does not save and vanishes after refreshing.

**Explanation:** This is because Next does an analysis during build time and tries to determine whether the pages at each route is either 'static' or 'dynamic'. In this case, it assumed the home page to be static, and thus it applied aggressive caching where the original database entries are stored as a HTML file and is being displayed every time the home page is refreshed, instead of dynamically updating the page.

When you run npm run build, you can understand whether a route is static or dynamic by the icons next to each route.

If it's static, Next will render the page NOW, ONE TIME and give that version to everyone who visits the app.

If it's dynamic, Next will render the page whenever someone visits it.

○ = static
λ = dynamic

```bash
Route (app)                           Size    First Load JS
○ /                                   179 B        92.3 kB
○ /_not-found                         882 B          86 kB
λ /snippets/[id]                      179 B        92.3 kB
λ /snippets/[id]/edit                 5.83 kB      90.9 kB
○ /snippets/new                       1.28 kB      86.4 kB
+ First Load JS shared by all         85.1 kB
  ├ chunks/472-fb6ee76b298be2bf.js    30 kB
  ├ chunks/fd9d1056-79f0c34c4a70824.js 53.2 kB
  ├ chunks/main-app-a38d38270e6168fd.js 232 B
  └ chunks/webpack-937a30abe1c5566f.js 1.73 kB
```

## How to Make a Page Dynamic in NextJS
- All pages are static by default.

To make a page dynamic, we can do any of these things:
- Calling a dynamic function or referencing a dynamic variable when your route renders. (like `cookies.set()`, `cookies.delete()`, `useSearchParams()`, `searchParams prop`)
- Assigning specific 'route segment config' options. (like `export const dynamic = 'force-dynamic'`, `export const revalidate = 0`)
- Calling fetch and opting out of caching of the response. (`fetch('...', {next: {revalidate: 0}});`)
- Using a dynamic route. (like `/snippets/[id]/page.tsx`)

## Caching
**Data Cache** - Responses made from requests made with 'fetch' are stored and used across requests.

**Router Cache** - 'Soft' navigation between routes are cached in the browser and reused when a user revisits the page.

**Request Memorization** - Make two or more 'GET' requests with 'fetch' during a user's request to your server? Only one 'GET' is actually executed.

**Full Route Cache** - At build time, Next decides if your route is static or dynamic. If it is static, the page is rendered and the result is stored. In production, users are given this pre-rendered result.

## Ways to Control Caching
**Time-Based:** - Every 'x' seconds, ignore the cached response and fetch new data. (`export const revalidate = x`, where x is the number of seconds.). This can be used in the front page of a social media site, because the data is changing every second, so we can configure to re render every 10 seconds or more.

**On-Demand:** - Forcibly purge a cached response.
```jsx
import {revalidatePath} from 'next/cache';
revalidatePath('/snippets');
```
This will be used in an app where we know exactly when the data changes and the user always needs to see up-to-date data.

**Disable Caching:** - Don't do any caching at all. (`export const revalidate = 0` or `export const dynamic = "force-dynamic"`)
Can be used in an app where we don't know when  the data changes or if the data is going to be different with every request, and the user expects updated data. For example, with external API calls.

## Making a 'wildcard'/[id] dynamic page use Caching
- Without caching, we miss out on some performance improvements.
- We can use `generateStaticParams` to do this.
What happens here is that it fetches the id params from the db only once during build time and builds params from the data from db i.e 1,2,3 and caches it.

Example for [id]:
```tsx
export async function generateStaticParams(){
  const snippets = await db.snippet.findMany();

  return snippets.map((snippet) => {
    return {
      id: snippet.id.toString(),
    };
  })
}
```
